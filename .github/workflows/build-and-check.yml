name: Build and Check Browser Extension

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release Type'
        required: true
        default: 'test'
        type: choice
        options:
          - test
          - production
      prerelease:
        description: 'Mark as Pre-release'
        required: false
        default: true
        type: boolean

jobs:
  build-and-check:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: |
          if [ -f "package-lock.json" ]; then
            npm ci
          else
            npm install
          fi

      - name: Dependency audit
        run: npm audit --production || true
        continue-on-error: true

      - name: TypeScript check
        run: npx tsc --noEmit

      - name: Lint check
        run: |
          if [ -f "package.json" ] && grep -q "eslint" package.json; then
            npm run lint
          else
            echo "‚ÑπÔ∏è ESLint not configured, skipping lint check"
          fi

      - name: Format check
        run: |
          if [ -f "package.json" ] && grep -q "prettier" package.json; then
            npm run format:check
          else
            echo "‚ÑπÔ∏è Prettier not configured, skipping format check"
          fi

      - name: Check manifest validity
        run: |
          if [ -f "package.json" ]; then
            echo "‚úì Checking manifest configuration in package.json"
            cat package.json | grep -A 20 "manifest"
          else
            echo "‚úó package.json not found"
            exit 1
          fi

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Get project version
        id: get_version
        run: |
          VERSION=$(jq -r '.version' package.json)
          PROJECT_NAME=$(jq -r '.name' package.json)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "project_name=$PROJECT_NAME" >> $GITHUB_OUTPUT
          echo "build_dir=${PROJECT_NAME}-${VERSION}" >> $GITHUB_OUTPUT
          echo "zip_file=${PROJECT_NAME}-${VERSION}.zip" >> $GITHUB_OUTPUT

      - name: Build extension
        run: |
          # Clean and rebuild
          rm -rf .plasmo build
          npm run build:ci
        env:
          CI: true
          NODE_ENV: production

      - name: Verify build success
        run: |
          if [ ! -d "build" ]; then
            echo "‚úó Build directory not found"
            exit 1
          fi
          # Find production build directory (flexible for different plasmo configs)
          PROD_BUILD=$(find build -type d -name "chrome-mv3-prod" -o -name "*-mv3-prod" | head -1)
          if [ -z "$PROD_BUILD" ]; then
            echo "‚úó Production build directory not found"
            echo "Available directories in build/:"
            ls -la build/
            exit 1
          fi
          echo "‚úì Production build directory found: $PROD_BUILD"

      - name: Check manifest.json
        run: |
          PROD_BUILD=$(find build -type d -name "chrome-mv3-prod" -o -name "*-mv3-prod" | head -1)
          if [ -f "$PROD_BUILD/manifest.json" ]; then
            echo "‚úì manifest.json exists"
            cat "$PROD_BUILD/manifest.json"
            if command -v jq &> /dev/null; then
              jq '.' "$PROD_BUILD/manifest.json"
              echo "‚úì manifest.json is valid JSON"
            else
              echo "‚ÑπÔ∏è jq not available, skipping JSON validation"
            fi
          else
            echo "‚úó manifest.json not found"
            exit 1
          fi

      - name: Package extension
        if: github.event_name == 'workflow_dispatch'
        run: npm run package

      - name: Prepare release assets
        if: github.event_name == 'workflow_dispatch'
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          PROJECT_NAME="${{ steps.get_version.outputs.project_name }}"
          BUILD_DIR="${{ steps.get_version.outputs.build_dir }}"
          ZIP_FILE="${{ steps.get_version.outputs.zip_file }}"

          # Use temp directory for all release operations
          TEMP_DIR=$(mktemp -d)
          echo "temp_dir=$TEMP_DIR" >> $GITHUB_ENV

          PROD_BUILD=$(find build -type d -name "chrome-mv3-prod" -o -name "*-mv3-prod" | head -1)

          if [ -n "$PROD_BUILD" ]; then
            cp -r "$PROD_BUILD" "$TEMP_DIR/$BUILD_DIR"
            echo "‚úì Copied build to temp directory: $TEMP_DIR/$BUILD_DIR"
          fi

          ZIP_PATH=$(find build -name "*.zip" | head -1)
          if [ -f "$ZIP_PATH" ]; then
            cp "$ZIP_PATH" "$TEMP_DIR/$ZIP_FILE"
            echo "‚úì Copied zip to temp directory: $TEMP_DIR/$ZIP_FILE"
          fi

          # Store paths for release step
          echo "release_build_dir=$TEMP_DIR/$BUILD_DIR" >> $GITHUB_ENV
          echo "release_zip_file=$TEMP_DIR/$ZIP_FILE" >> $GITHUB_ENV

      - name: Verify zip file creation
        if: github.event_name == 'workflow_dispatch'
        run: |
          ZIP_FILE=$release_zip_file
          if [ -f "$ZIP_FILE" ]; then
            echo "‚úì Zip file ready: $ZIP_FILE"
            ls -la "$ZIP_FILE"
            ZIP_SIZE=$(wc -c < "$ZIP_FILE")
            echo "‚úì Zip file size: $ZIP_SIZE bytes"
            if [ "$ZIP_SIZE" -lt 1000 ]; then
              echo "‚ö†Ô∏è Zip file is very small, may be incomplete"
            fi
          else
            echo "‚úó Zip file not found"
            exit 1
          fi

      - name: Verify build artifacts
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "üìÅ Build artifacts in temp directory:"
          ls -la $release_build_dir

          REQUIRED_FILES=("manifest.json" "popup.html")
          for file in "${REQUIRED_FILES[@]}"; do
            if [ -f "$release_build_dir/$file" ]; then
              echo "‚úì $file exists"
            else
              echo "‚úó $file missing"
              exit 1
            fi
          done

          if [ -f "$release_build_dir/background.js" ] || [ -f "$release_build_dir/background/index.js" ]; then
            echo "‚úì background script exists"
          else
            echo "‚ÑπÔ∏è background script not found"
          fi

      - name: Generate release notes
        if: github.event_name == 'workflow_dispatch'
        id: release_notes
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          TEMP_DIR="${{ env.temp_dir }}"

          # Get the last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          # Initialize categories
          declare -A categories
          categories=(
            ["feat"]="‚ú® Features"
            ["fix"]="üêõ Bug Fixes"
            ["refactor"]="‚ôªÔ∏è Refactoring"
            ["perf"]="‚ö° Performance"
            ["docs"]="üìö Documentation"
            ["style"]="üíÑ Styles"
            ["test"]="üß™ Tests"
            ["chore"]="üîß Chores"
            ["ci"]="üë∑ CI/CD"
            ["build"]="üì¶ Build"
            ["other"]="üìù Other Changes"
          )

          # Create temp files for each category
          for key in "${!categories[@]}"; do
            touch "$TEMP_DIR/commits_$key.txt"
          done

          # Get commits and categorize them
          if [ -z "$LAST_TAG" ]; then
            COMMITS=$(git log --pretty=format:"%s|%h" 2>/dev/null)
            echo "## üéâ First Release v$VERSION" > $TEMP_DIR/RELEASE_NOTES.md
          else
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"%s|%h" 2>/dev/null)
            echo "## üöÄ Release v$VERSION" > $TEMP_DIR/RELEASE_NOTES.md
            echo "" >> $TEMP_DIR/RELEASE_NOTES.md
            echo "**Full Changelog**: [$LAST_TAG...v$VERSION](../../compare/$LAST_TAG...v$VERSION)" >> $TEMP_DIR/RELEASE_NOTES.md
          fi

          echo "" >> $TEMP_DIR/RELEASE_NOTES.md

          # Parse and categorize commits
          while IFS='|' read -r message hash; do
            [ -z "$message" ] && continue

            # Extract type and description
            if [[ $message =~ ^([a-z]+)(\(.+\))?!?:[[:space:]]*(.+)$ ]]; then
              type="${BASH_REMATCH[1]}"
              desc="${BASH_REMATCH[3]}"
            else
              type="other"
              desc="$message"
            fi

            # Map conventional commit types to categories
            case "$type" in
              feat|feature) category="feat" ;;
              fix|bugfix|hotfix) category="fix" ;;
              refactor) category="refactor" ;;
              perf|performance) category="perf" ;;
              docs|doc) category="docs" ;;
              style) category="style" ;;
              test|tests) category="test" ;;
              chore) category="chore" ;;
              ci) category="ci" ;;
              build) category="build" ;;
              *) category="other" ;;
            esac

            echo "- $desc (${hash:0:7})" >> "$TEMP_DIR/commits_$category.txt"
          done <<< "$COMMITS"

          # Write categorized commits to release notes (only non-empty categories)
          has_changes=false
          for key in feat fix refactor perf docs style test chore ci build other; do
            if [ -s "$TEMP_DIR/commits_$key.txt" ]; then
              echo "### ${categories[$key]}" >> $TEMP_DIR/RELEASE_NOTES.md
              echo "" >> $TEMP_DIR/RELEASE_NOTES.md
              cat "$TEMP_DIR/commits_$key.txt" >> $TEMP_DIR/RELEASE_NOTES.md
              echo "" >> $TEMP_DIR/RELEASE_NOTES.md
              has_changes=true
            fi
          done

          # If no categorized changes found
          if [ "$has_changes" = false ]; then
            echo "*No significant changes in this release.*" >> $TEMP_DIR/RELEASE_NOTES.md
            echo "" >> $TEMP_DIR/RELEASE_NOTES.md
          fi

          # Add installation section (only for non-patch releases or first release)
          if [ -z "$LAST_TAG" ] || [[ ! "$VERSION" =~ \.[0-9]+$ ]]; then
            {
              echo "## üì¶ Installation"
              echo ""
              echo "### Chrome Web Store (Coming Soon)"
              echo "1. Visit the Chrome Web Store"
              echo "2. Search for \"LXHistory_Sync\""
              echo "3. Click \"Add to Chrome\""
              echo ""
              echo "### Manual Installation"
              echo "1. Download the \`.zip\` file from this release"
              echo "2. Extract the contents"
              echo "3. Open Chrome and navigate to \`chrome://extensions/\`"
              echo "4. Enable \"Developer mode\" in the top right"
              echo "5. Click \"Load unpacked\" and select the extracted folder"
              echo ""
            } >> $TEMP_DIR/RELEASE_NOTES.md
          fi

          # Add files section
          {
            echo ""
            echo "## üìÑ Files"
            echo ""
            echo "- \`LXHistory_Sync-v${VERSION}.zip\` - Chrome Extension package"
            echo ""
          } >> $TEMP_DIR/RELEASE_NOTES.md

          echo "notes_file=$TEMP_DIR/RELEASE_NOTES.md" >> $GITHUB_OUTPUT
          echo "‚úì Release notes generated"
          cat $TEMP_DIR/RELEASE_NOTES.md

      - name: Security check
        run: |
          echo "üîí Running security checks..."
          SECURITY_ISSUES=0

          if grep -r "eval(" --include="*.ts" --include="*.tsx" --include="*.js" --include="*.jsx" . 2>/dev/null | grep -v "node_modules" | grep -v ".plasmo" | head -1; then
            echo "‚ö†Ô∏è  Found eval() usage, potential security risk"
            SECURITY_ISSUES=1
          else
            echo "‚úì No eval() usage found"
          fi

          if grep -r "innerHTML" --include="*.ts" --include="*.tsx" --include="*.js" --include="*.jsx" . 2>/dev/null | grep -v "node_modules" | grep -v ".plasmo" | head -1; then
            echo "‚ö†Ô∏è  Found innerHTML usage, potential XSS risk"
            SECURITY_ISSUES=1
          else
            echo "‚úì No innerHTML usage found"
          fi

          if grep -r "dangerouslySetInnerHTML" --include="*.ts" --include="*.tsx" --include="*.js" --include="*.jsx" . 2>/dev/null | grep -v "node_modules" | grep -v ".plasmo" | head -1; then
            echo "‚ö†Ô∏è  Found dangerouslySetInnerHTML usage, potential XSS risk"
            SECURITY_ISSUES=1
          else
            echo "‚úì No dangerouslySetInnerHTML usage found"
          fi

          if [ $SECURITY_ISSUES -eq 0 ]; then
            echo "‚úÖ All security checks passed"
          else
            echo "‚ö†Ô∏è  Security issues found, please review"
          fi

      - name: List build directory
        run: |
          echo "üìÅ Build directory contents:"
          ls -la build/
          echo "üìÅ Chrome MV3 Prod contents:"
          ls -la build/chrome-mv3-prod/ || echo "Directory not found"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: extension-build
          path: |
            build/chrome-mv3-prod/
          retention-days: 7

      - name: Create Release
        if: github.event_name == 'workflow_dispatch'
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          PRERELEASE="${{ github.event.inputs.prerelease }}"
          NOTES_FILE="${{ steps.release_notes.outputs.notes_file }}"
          ZIP_FILE="${{ env.release_zip_file }}"

          # Generate tag and title based on release type
          if [ "$RELEASE_TYPE" == "production" ]; then
            TAG_NAME="v${VERSION}"
            RELEASE_TITLE="üöÄ Release v${VERSION}"
          else
            # Test release: add timestamp to tag
            TIMESTAMP=$(date +%Y%m%d%H%M%S)
            TAG_NAME="v${VERSION}-test-${TIMESTAMP}"
            RELEASE_TITLE="üß™ Test Release v${VERSION} (${TIMESTAMP})"
          fi

          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "‚ÑπÔ∏è Tag $TAG_NAME already exists"
            if [ "$RELEASE_TYPE" == "production" ]; then
              echo "‚ùå Production release tag already exists. Please update the version in package.json"
              exit 1
            else
              echo "‚ÑπÔ∏è Skipping test release creation"
            fi
          else
            echo "üì¶ Creating $RELEASE_TYPE release: $TAG_NAME"

            # Add release type notice to notes
            if [ "$RELEASE_TYPE" == "test" ]; then
              echo "" >> $NOTES_FILE
              echo "---" >> $NOTES_FILE
              echo "" >> $NOTES_FILE
              echo "> ‚ö†Ô∏è **This is a TEST release**" >> $NOTES_FILE
              echo "> " >> $NOTES_FILE
              echo "> This release is for testing purposes only and may contain unstable features." >> $NOTES_FILE
              echo "> For production use, please download the [latest stable release](../../releases/latest)." >> $NOTES_FILE
              echo "> " >> $NOTES_FILE
              echo "> **Build Info:**" >> $NOTES_FILE
              echo "> - Build Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $NOTES_FILE
              echo "> - Commit: ${{ github.sha }}" >> $NOTES_FILE
              echo "> - Branch: ${{ github.ref_name }}" >> $NOTES_FILE
            fi

            # Create release with appropriate flags
            if [ "$PRERELEASE" == "true" ] || [ "$RELEASE_TYPE" == "test" ]; then
              gh release create "$TAG_NAME" \
                --title "$RELEASE_TITLE" \
                --notes-file "$NOTES_FILE" \
                --prerelease \
                "$ZIP_FILE"
            else
              gh release create "$TAG_NAME" \
                --title "$RELEASE_TITLE" \
                --notes-file "$NOTES_FILE" \
                --latest \
                "$ZIP_FILE"
            fi
            echo "‚úÖ Release created successfully: $TAG_NAME"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup temp files
        if: github.event_name == 'workflow_dispatch' && always()
        run: |
          if [ -n "$temp_dir" ] && [ -d "$temp_dir" ]; then
            rm -rf "$temp_dir"
            echo "‚úÖ Cleaned up temporary files"
          fi

      - name: Summary
        run: |
          echo "## Build Summary"
          echo "‚úÖ All checks passed"
          echo "‚úÖ Build completed successfully"
          echo "‚úÖ TypeScript check passed"
          echo "‚úÖ Dependency audit completed"

          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            RELEASE_TYPE=${{ github.event.inputs.release_type }}
            PRERELEASE=${{ github.event.inputs.prerelease }}

            echo ""
            echo "## Release Information"
            echo "üì¶ Release Type: $RELEASE_TYPE"
            if [ "$RELEASE_TYPE" == "test" ]; then
              echo "üîñ Tag Format: v{VERSION}-test-{TIMESTAMP}"
              echo "‚ö†Ô∏è  Pre-release: true (forced for test releases)"
            else
              echo "üîñ Tag Format: v{VERSION}"
              echo "‚ö†Ô∏è  Pre-release: $PRERELEASE"
            fi
            echo ""
            echo "‚úÖ Extension packaged"
            echo "‚úÖ Build artifacts uploaded"
            echo "‚úÖ Release notes generated"
            echo "‚úÖ Release created"
            echo "‚úÖ Ready for deployment"
          else
            echo "‚úÖ Code inspection completed"
            echo "‚úÖ No issues found"
            echo "‚ÑπÔ∏è Package and release steps skipped (manual trigger only)"
          fi

  unit-test:
    runs-on: ubuntu-latest
    needs: build-and-check
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: |
          if [ -f "package-lock.json" ]; then
            npm ci
          else
            npm install
          fi

      - name: Run unit tests with coverage
        run: npm run test:unit -- --coverage

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          slug: ${{ github.repository }}
          files: /tmp/coverage/lcov.info
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false
          verbose: true

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-results
          path: /tmp/test-results/
          retention-days: 7

  e2e-test:
    runs-on: ubuntu-latest
    needs: build-and-check
    permissions:
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: |
          if [ -f "package-lock.json" ]; then
            npm ci
          else
            npm install
          fi

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: extension-build
          path: build/

      - name: Verify downloaded build
        run: |
          echo "üìÅ Downloaded build contents:"
          ls -la build/
          echo "üìÅ Chrome MV3 Prod contents:"
          ls -la build/chrome-mv3-prod/ || echo "Directory not found"
          echo "üìÅ manifest.json:"
          cat build/chrome-mv3-prod/manifest.json || echo "manifest.json not found"

      - name: Run E2E tests
        run: npm run test:e2e

      - name: Upload Playwright report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: |
            /tmp/playwright-report/
            test-results/
          retention-days: 7
