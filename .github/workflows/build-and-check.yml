name: Build and Check Browser Extension

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release Type'
        required: true
        default: 'test'
        type: choice
        options:
          - test
          - production
      prerelease:
        description: 'Mark as Pre-release'
        required: false
        default: true
        type: boolean

jobs:
  build-and-check:
    runs-on: ubuntu-latest
    env:
      PROD_BUILD_PATH: build/chrome-mv3-prod
    permissions:
      contents: write
      packages: write
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Cache node modules
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        run: npm ci

      - name: Dependency audit
        run: npm audit --production || true
        continue-on-error: true

      - name: TypeScript check
        run: npx tsc --noEmit

      - name: ESLint ä»£ç è§„èŒƒæ£€æŸ¥
        run: |
          if [ -f "package.json" ] && grep -q "eslint" package.json; then
            npm run lint
          else
            echo "â„¹ï¸ æœªé…ç½® ESLintï¼Œè·³è¿‡æ£€æŸ¥"
          fi

      - name: Prettier æ ¼å¼æ£€æŸ¥
        run: |
          if [ -f "package.json" ] && grep -q "prettier" package.json; then
            npm run format:check
          else
            echo "â„¹ï¸ æœªé…ç½® Prettierï¼Œè·³è¿‡æ£€æŸ¥"
          fi

      - name: Get project version
        id: get_version
        run: |
          VERSION=$(jq -r '.version' package.json)
          PROJECT_NAME=$(jq -r '.name' package.json)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "project_name=$PROJECT_NAME" >> $GITHUB_OUTPUT
          echo "build_dir=${PROJECT_NAME}-${VERSION}" >> $GITHUB_OUTPUT
          echo "zip_file=${PROJECT_NAME}-${VERSION}.zip" >> $GITHUB_OUTPUT

      - name: Build extension
        run: |
          rm -rf .plasmo build
          npm run build:ci
        env:
          CI: true
          NODE_ENV: production

      - name: Verify build and manifest
        run: |
          if [ ! -d "$PROD_BUILD_PATH" ]; then
            # Fallback to dynamic search if env path doesn't exist
            PROD_BUILD_PATH=$(find build -type d -name "chrome-mv3-prod" -o -name "*-mv3-prod" | head -1)
          fi
          
          if [ -z "$PROD_BUILD_PATH" ] || [ ! -d "$PROD_BUILD_PATH" ]; then
            echo "âŒ Production build directory not found"
            ls -la build/ || true
            exit 1
          fi
          echo "âœ… Production build directory found: $PROD_BUILD_PATH"
          echo "PROD_BUILD_PATH=$PROD_BUILD_PATH" >> $GITHUB_ENV
          
          REQUIRED_FILES=("manifest.json" "popup.html")
          for file in "${REQUIRED_FILES[@]}"; do
            if [ -f "$PROD_BUILD_PATH/$file" ]; then
              echo "âœ… $file exists"
            else
              echo "âŒ $file missing"
              exit 1
            fi
          done

          if command -v jq &> /dev/null; then
            jq '.' "$PROD_BUILD_PATH/manifest.json" > /dev/null
            echo "âœ… manifest.json is valid JSON"
            
            # Security check: Ensure no dangerous permissions
            PERMISSIONS=$(jq -r '.permissions[]' "$PROD_BUILD_PATH/manifest.json" 2>/dev/null || echo "")
            if echo "$PERMISSIONS" | grep -q "browsingData"; then
              echo "âš ï¸ Extension uses browsingData permission"
            fi
          fi

      - name: Package extension
        if: github.event_name == 'workflow_dispatch'
        run: npm run package

      - name: Prepare release assets
        if: github.event_name == 'workflow_dispatch'
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          PROJECT_NAME="${{ steps.get_version.outputs.project_name }}"
          BUILD_DIR="${{ steps.get_version.outputs.build_dir }}"
          ZIP_FILE="${{ steps.get_version.outputs.zip_file }}"

          TEMP_DIR=$(mktemp -d)
          echo "temp_dir=$TEMP_DIR" >> $GITHUB_ENV

          if [ -n "$PROD_BUILD_PATH" ] && [ -d "$PROD_BUILD_PATH" ]; then
            cp -r "$PROD_BUILD_PATH" "$TEMP_DIR/$BUILD_DIR"
            echo "âœ… Copied build to temp directory: $TEMP_DIR/$BUILD_DIR"
          fi

          ZIP_PATH=$(find build -name "*.zip" | head -1)
          if [ -f "$ZIP_PATH" ]; then
            cp "$ZIP_PATH" "$TEMP_DIR/$ZIP_FILE"
            echo "âœ… å·²å°†å‹ç¼©åŒ…å¤åˆ¶åˆ°ä¸´æ—¶ç›®å½•: $TEMP_DIR/$ZIP_FILE"
          fi

          echo "release_build_dir=$TEMP_DIR/$BUILD_DIR" >> $GITHUB_ENV
          echo "release_zip_file=$TEMP_DIR/$ZIP_FILE" >> $GITHUB_ENV

      - name: éªŒè¯å‹ç¼©åŒ…åˆ›å»º
        if: github.event_name == 'workflow_dispatch'
        run: |
          ZIP_FILE=$release_zip_file
          if [ -f "$ZIP_FILE" ]; then
            echo "âœ… å‹ç¼©åŒ…å·²å°±ç»ª: $ZIP_FILE"
            ls -la "$ZIP_FILE"
            ZIP_SIZE=$(wc -c < "$ZIP_FILE")
            echo "âœ… å‹ç¼©åŒ…å¤§å°: $ZIP_SIZE å­—èŠ‚"
            if [ "$ZIP_SIZE" -lt 1000 ]; then
              echo "âš ï¸ å‹ç¼©åŒ…éå¸¸å°ï¼Œå¯èƒ½ä¸å®Œæ•´"
            fi
          else
            echo "âŒ æœªæ‰¾åˆ°å‹ç¼©åŒ…"
            exit 1
          fi

      - name: Verify build artifacts
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "ğŸ“‚ Build artifacts in temp directory:"
          ls -la $release_build_dir

          REQUIRED_FILES=("manifest.json" "popup.html")
          for file in "${REQUIRED_FILES[@]}"; do
            if [ -f "$release_build_dir/$file" ]; then
              echo "âœ… $file exists"
            else
              echo "âŒ $file missing"
              exit 1
            fi
          done

          if [ -f "$release_build_dir/background.js" ] || [ -f "$release_build_dir/background/index.js" ] || [ -f "$release_build_dir/background.index.js" ]; then
            echo "âœ… background script exists"
          else
            echo "â„¹ï¸ background script not found"
          fi

      - name: Generate release notes
        if: github.event_name == 'workflow_dispatch'
        id: release_notes
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          TEMP_DIR="${{ env.temp_dir }}"

          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          declare -A categories
          categories=(
            ["feat"]="ğŸš€ Features"
            ["fix"]="ğŸ› Bug Fixes"
            ["refactor"]="â™»ï¸ Refactoring"
            ["perf"]="âš¡ Performance"
            ["docs"]="ğŸ“ Documentation"
            ["style"]="ğŸ’„ Styles"
            ["test"]="ğŸ§ª Tests"
            ["chore"]="ğŸ”§ Chores"
            ["ci"]="ğŸ‘· CI/CD"
            ["build"]="ğŸ“¦ Build"
            ["revert"]="âª Reverts"
            ["security"]="ğŸ”’ Security"
            ["other"]="ğŸ“ Other Changes"
          )

          for key in "${!categories[@]}"; do
            touch "$TEMP_DIR/commits_$key.txt"
          done

          if [ -z "$LAST_TAG" ]; then
            COMMITS=$(git log --pretty=format:"%s|%h" 2>/dev/null)
            echo "## ğŸ‰ First Release v$VERSION" > $TEMP_DIR/RELEASE_NOTES.md
          else
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"%s|%h" 2>/dev/null)
            echo "## ğŸš€ Release v$VERSION" > $TEMP_DIR/RELEASE_NOTES.md
            echo "" >> $TEMP_DIR/RELEASE_NOTES.md
            echo "**Full Changelog**: [$LAST_TAG...v$VERSION](../../compare/$LAST_TAG...v$VERSION)" >> $TEMP_DIR/RELEASE_NOTES.md
          fi

          echo "" >> $TEMP_DIR/RELEASE_NOTES.md

          while IFS='|' read -r message hash; do
            [ -z "$message" ] && continue

            if [[ $message =~ ^([a-z]+)(\(.+\))?!?:[[:space:]]*(.+)$ ]]; then
              type="${BASH_REMATCH[1]}"
              scope="${BASH_REMATCH[2]}"
              desc="${BASH_REMATCH[3]}"
              
              # Clean up scope if it exists
              if [ -n "$scope" ]; then
                scope="${scope#(}"
                scope="${scope%)}"
                display_desc="**$scope**: $desc"
              else
                display_desc="$desc"
              fi
            else
              type="other"
              display_desc="$message"
            fi

            case "$type" in
              feat|feature) category="feat" ;;
              fix|bugfix|hotfix) category="fix" ;;
              refactor) category="refactor" ;;
              perf|performance) category="perf" ;;
              docs|doc) category="docs" ;;
              style) category="style" ;;
              test|tests) category="test" ;;
              chore) category="chore" ;;
              ci) category="ci" ;;
              build) category="build" ;;
              revert) category="revert" ;;
              security) category="security" ;;
              *) category="other" ;;
            esac

            echo "- $display_desc (${hash:0:7})" >> "$TEMP_DIR/commits_$category.txt"
          done <<< "$COMMITS"

          has_changes=false
          for key in feat fix security refactor perf docs style test chore ci build revert other; do
            if [ -s "$TEMP_DIR/commits_$key.txt" ]; then
              echo "### ${categories[$key]}" >> $TEMP_DIR/RELEASE_NOTES.md
              echo "" >> $TEMP_DIR/RELEASE_NOTES.md
              cat "$TEMP_DIR/commits_$key.txt" >> $TEMP_DIR/RELEASE_NOTES.md
              echo "" >> $TEMP_DIR/RELEASE_NOTES.md
              has_changes=true
            fi
          done

          if [ "$has_changes" = false ]; then
            echo "*No significant changes in this release.*" >> $TEMP_DIR/RELEASE_NOTES.md
            echo "" >> $TEMP_DIR/RELEASE_NOTES.md
          fi

          if [ -z "$LAST_TAG" ] || [[ ! "$VERSION" =~ \.[0-9]+$ ]]; then
            {
              echo "## ğŸ“¦ Installation"
              echo ""
              echo "### Chrome Web Store (Coming Soon)"
              echo "1. Visit the Chrome Web Store"
              echo "2. Search for \"LXHistory_Sync\""
              echo "3. Click \"Add to Chrome\""
              echo ""
              echo "### Manual Installation"
              echo "1. Download the \`.zip\` file from this release"
              echo "2. Extract the contents"
              echo "3. Open Chrome and navigate to \`chrome://extensions/\`"
              echo "4. Enable \"Developer mode\" in the top right"
              echo "5. Click \"Load unpacked\" and select the extracted folder"
              echo ""
            } >> $TEMP_DIR/RELEASE_NOTES.md
          fi

          {
            echo ""
            echo "## ğŸ“‚ Files"
            echo ""
            echo "- \`LXHistory_Sync-v${VERSION}.zip\` - Chrome Extension package"
            echo ""
          } >> $TEMP_DIR/RELEASE_NOTES.md

          echo "notes_file=$TEMP_DIR/RELEASE_NOTES.md" >> $GITHUB_OUTPUT
          echo "âœ… Release notes generated"
          cat $TEMP_DIR/RELEASE_NOTES.md

      - name: Security check
        run: |
          echo "ğŸ” Running security checks..."
          SECURITY_ISSUES=0

          # Check for dangerous functions
          DANGEROUS_FUNCS=("eval(" "setTimeout(" "setInterval(" "new Function(")
          for func in "${DANGEROUS_FUNCS[@]}"; do
            if grep -r "$func" --include="*.ts" --include="*.tsx" --include="*.js" --include="*.jsx" . 2>/dev/null | grep -v "node_modules" | grep -v ".plasmo" | head -1; then
              echo "âš ï¸  Found $func usage, potential security risk"
              # We don't increment SECURITY_ISSUES for setTimeout/setInterval as they are common, but we flag them
              if [[ "$func" == "eval(" || "$func" == "new Function(" ]]; then
                SECURITY_ISSUES=1
              fi
            fi
          done

          # Check for XSS risks
          XSS_RISKS=("innerHTML" "dangerouslySetInnerHTML" "document.write(")
          for risk in "${XSS_RISKS[@]}"; do
            if grep -r "$risk" --include="*.ts" --include="*.tsx" --include="*.js" --include="*.jsx" . 2>/dev/null | grep -v "node_modules" | grep -v ".plasmo" | head -1; then
              echo "âš ï¸  Found $risk usage, potential XSS risk"
              SECURITY_ISSUES=1
            fi
          done

          # Check for hardcoded secrets (basic check)
          if grep -rE "api_key|secret|password|token" --include="*.ts" --include="*.tsx" . 2>/dev/null | grep -v "node_modules" | grep -v ".plasmo" | grep -v "test" | grep -E "['\"][a-zA-Z0-9]{20,}['\"]" | head -1; then
            echo "âš ï¸  Potential hardcoded secret found"
            SECURITY_ISSUES=1
          fi

          if [ $SECURITY_ISSUES -eq 0 ]; then
            echo "âœ… All security checks passed"
          else
            echo "âš ï¸  Security issues found, please review"
          fi

      - name: List build directory
        run: |
          echo "ğŸ“‚ Build directory contents:"
          ls -la build/
          echo "ğŸ“‚ Chrome MV3 Prod contents:"
          ls -la "$PROD_BUILD_PATH" || echo "Directory not found"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: extension-build
          path: build/
          retention-days: 7

      - name: Create Release
        if: github.event_name == 'workflow_dispatch'
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          PRERELEASE="${{ github.event.inputs.prerelease }}"
          NOTES_FILE="${{ steps.release_notes.outputs.notes_file }}"
          ZIP_FILE="${{ env.release_zip_file }}"

          if [ "$RELEASE_TYPE" == "production" ]; then
            TAG_NAME="v${VERSION}"
            RELEASE_TITLE="ğŸš€ Release v${VERSION}"
          else
            TIMESTAMP=$(date +%Y%m%d%H%M%S)
            TAG_NAME="v${VERSION}-test-${TIMESTAMP}"
            RELEASE_TITLE="ğŸ§ª Test Release v${VERSION} (${TIMESTAMP})"
          fi

          # Check if tag already exists
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "âš ï¸ Tag $TAG_NAME already exists"
            if [ "$RELEASE_TYPE" == "production" ]; then
              # For production, we fail to prevent accidental overwrites
              echo "âŒ Production release tag already exists. Please update the version in package.json"
              exit 1
            else
              # For test releases, we append a random string to avoid conflict
              RANDOM_SUFFIX=$(head /dev/urandom | tr -dc a-z0-9 | head -c 4)
              TAG_NAME="${TAG_NAME}-${RANDOM_SUFFIX}"
              RELEASE_TITLE="${RELEASE_TITLE} (${RANDOM_SUFFIX})"
              echo "âš ï¸ Conflict detected, using new tag: $TAG_NAME"
            fi
          fi

          echo "ğŸ“¦ Creating $RELEASE_TYPE release: $TAG_NAME"

          if [ "$RELEASE_TYPE" == "test" ]; then
            echo "" >> $NOTES_FILE
            echo "---" >> $NOTES_FILE
            echo "" >> $NOTES_FILE
            echo "> âš ï¸ **è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•ç‰ˆæœ¬**" >> $NOTES_FILE
            echo "> " >> $NOTES_FILE
            echo "> æ­¤ç‰ˆæœ¬ä»…ç”¨äºæµ‹è¯•ï¼Œå¯èƒ½åŒ…å«ä¸ç¨³å®šåŠŸèƒ½ã€‚" >> $NOTES_FILE
            echo "> å¦‚éœ€ç”Ÿäº§ä½¿ç”¨ï¼Œè¯·ä¸‹è½½ [æœ€æ–°ç¨³å®šç‰ˆæœ¬](../../releases/latest)ã€‚" >> $NOTES_FILE
            echo "> " >> $NOTES_FILE
            echo "> **æ„å»ºä¿¡æ¯:**" >> $NOTES_FILE
            echo "> - æ„å»ºæ—¶é—´: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $NOTES_FILE
            echo "> - æäº¤å“ˆå¸Œ: ${{ github.sha }}" >> $NOTES_FILE
            echo "> - åˆ†æ”¯: ${{ github.ref_name }}" >> $NOTES_FILE
          fi

          if [ "$PRERELEASE" == "true" ] || [ "$RELEASE_TYPE" == "test" ]; then
            gh release create "$TAG_NAME" \
              --title "$RELEASE_TITLE" \
              --notes-file "$NOTES_FILE" \
              --prerelease \
              "$ZIP_FILE"
          else
            gh release create "$TAG_NAME" \
              --title "$RELEASE_TITLE" \
              --notes-file "$NOTES_FILE" \
              --latest \
              "$ZIP_FILE"
          fi
          echo "âœ… å‘å¸ƒåˆ›å»ºæˆåŠŸ: $TAG_NAME"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        if: github.event_name == 'workflow_dispatch' && always()
        run: |
          if [ -n "$temp_dir" ] && [ -d "$temp_dir" ]; then
            rm -rf "$temp_dir"
            echo "âœ… å·²æ¸…ç†ä¸´æ—¶æ–‡ä»¶"
          fi

      - name: ä»»åŠ¡æ€»ç»“
        run: |
          echo "## æ„å»ºæ€»ç»“" >> $GITHUB_STEP_SUMMARY
          echo "âœ… æ‰€æœ‰æ£€æŸ¥å‡å·²é€šè¿‡" >> $GITHUB_STEP_SUMMARY
          echo "âœ… æ„å»ºæˆåŠŸå®Œæˆ" >> $GITHUB_STEP_SUMMARY
          echo "âœ… TypeScript æ£€æŸ¥é€šè¿‡" >> $GITHUB_STEP_SUMMARY
          echo "âœ… ä¾èµ–å®¡è®¡å®Œæˆ" >> $GITHUB_STEP_SUMMARY

          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            RELEASE_TYPE=${{ github.event.inputs.release_type }}
            echo ""
            echo "## å‘å¸ƒä¿¡æ¯" >> $GITHUB_STEP_SUMMARY
            echo "ğŸ“¦ å‘å¸ƒç±»å‹: $RELEASE_TYPE" >> $GITHUB_STEP_SUMMARY
            echo "âœ… æ‰©å±•ç¨‹åºå·²æ‰“åŒ…" >> $GITHUB_STEP_SUMMARY
            echo "âœ… æ„å»ºèµ„äº§å·²ä¸Šä¼ " >> $GITHUB_STEP_SUMMARY
            echo "âœ… å‘å¸ƒæ—¥å¿—å·²ç”Ÿæˆ" >> $GITHUB_STEP_SUMMARY
            echo "âœ… GitHub Release å·²åˆ›å»º" >> $GITHUB_STEP_SUMMARY
          fi

  unit-test:
    name: å•å…ƒæµ‹è¯•
    runs-on: ubuntu-latest
    needs: build-and-check
    permissions:
      contents: read
      id-token: write
    steps:
      - name: æ£€å‡ºä»£ç 
        uses: actions/checkout@v4

      - name: è®¾ç½® Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: ç¼“å­˜ä¾èµ–
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: å®‰è£…ä¾èµ–
        run: npm ci

      - name: è¿è¡Œå•å…ƒæµ‹è¯•å¹¶ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
        run: npm run test:unit -- --coverage
        env:
          VITEST_OUTPUT_DIR: /tmp/test-results
          VITEST_COVERAGE_DIR: /tmp/coverage

      - name: ä¸Šä¼ è¦†ç›–ç‡æŠ¥å‘Šåˆ° Codecov
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: /tmp/coverage/lcov.info
          flags: unittests
          fail_ci_if_error: false
          verbose: true

      - name: ä¸Šä¼ æµ‹è¯•ç»“æœ
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-results
          path: /tmp/test-results/
          retention-days: 7

  e2e-test:
    name: ç«¯åˆ°ç«¯æµ‹è¯• (E2E)
    runs-on: ubuntu-latest
    needs: build-and-check
    permissions:
      contents: read
    steps:
      - name: æ£€å‡ºä»£ç 
        uses: actions/checkout@v4

      - name: è®¾ç½® Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: ç¼“å­˜ä¾èµ–
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: å®‰è£…ä¾èµ–
        run: npm ci

      - name: è·å– Playwright ç‰ˆæœ¬
        id: playwright-version
        run: echo "version=$(npx playwright --version | cut -d' ' -f2)" >> $GITHUB_OUTPUT

      - name: ç¼“å­˜ Playwright æµè§ˆå™¨
        uses: actions/cache@v4
        id: playwright-cache
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ steps.playwright-version.outputs.version }}
          restore-keys: |
            ${{ runner.os }}-playwright-

      - name: å®‰è£… Playwright æµè§ˆå™¨
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        run: npx playwright install --with-deps

      - name: ä¸‹è½½æ„å»ºäº§ç‰©
        uses: actions/download-artifact@v4
        with:
          name: extension-build
          path: .

      - name: éªŒè¯æ„å»ºäº§ç‰©
        run: |
          echo "ğŸ“‚ å·²ä¸‹è½½æ„å»ºäº§ç‰©å†…å®¹:"
          ls -la build/
          
          # ä¼˜å…ˆå¯»æ‰¾å­ç›®å½•ï¼Œå¦‚æœæ‰¾ä¸åˆ°åˆ™æ£€æŸ¥ build/ ç›®å½•ä¸‹æ˜¯å¦ç›´æ¥å­˜åœ¨ manifest.json
          PROD_BUILD=$(find build -type d -name "chrome-mv3-prod" -o -name "*-mv3-prod" | head -1)
          
          if [ -z "$PROD_BUILD" ] && [ -f "build/manifest.json" ]; then
            PROD_BUILD="build"
          fi

          if [ -z "$PROD_BUILD" ] || [ ! -d "$PROD_BUILD" ]; then
            echo "âŒ æœªæ‰¾åˆ°æœ‰æ•ˆçš„ç”Ÿäº§æ„å»ºç›®å½•æˆ–æ–‡ä»¶"
            exit 1
          fi
          
          echo "âœ… æ‰¾åˆ°ç”Ÿäº§æ„å»ºç›®å½•: $PROD_BUILD"
          echo "PROD_BUILD=$PROD_BUILD" >> $GITHUB_ENV
          echo "ğŸ“‚ manifest.json å†…å®¹:"
          cat "$PROD_BUILD/manifest.json" || echo "æœªæ‰¾åˆ° manifest.json"

      - name: å®‰è£… rclone (ç”¨äº WebDAV æµ‹è¯•)
        run: |
          sudo -v && curl https://rclone.org/install.sh | sudo bash

      - name: å¯åŠ¨ä¸´æ—¶ WebDAV æœåŠ¡
        run: |
          mkdir -p /tmp/webdav-data
          nohup rclone serve webdav /tmp/webdav-data \
            --addr :8080 \
            --user testuser \
            --pass testpass \
            --vfs-cache-mode full \
            --log-file /tmp/webdav.log > /dev/null 2>&1 &
          echo "WEBDAV_URL=http://localhost:8080" >> $GITHUB_ENV
          echo "WEBDAV_USER=testuser" >> $GITHUB_ENV
          echo "WEBDAV_PASS=testpass" >> $GITHUB_ENV
          # ç­‰å¾…æœåŠ¡å¯åŠ¨å¹¶æ£€æŸ¥çŠ¶æ€
          sleep 5
          if ! curl -u testuser:testpass http://localhost:8080 > /dev/null 2>&1; then
            echo "âŒ WebDAV æœåŠ¡å¯åŠ¨å¤±è´¥"
            cat /tmp/webdav.log
            exit 1
          fi
          echo "âœ… WebDAV æœåŠ¡å·²å°±ç»ª"

      - name: è¿è¡Œ E2E æµ‹è¯•
        run: npm run test:e2e
        env:
          CI: true
          PLAYWRIGHT_HTML_REPORT: /tmp/playwright-report

      - name: ä¸Šä¼  E2E æµ‹è¯•æŠ¥å‘Š
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: |
            /tmp/playwright-report/
            test-results/
          retention-days: 7

  security-audit:
    name: å®‰å…¨ä¸è´¨é‡å®¡è®¡
    runs-on: ubuntu-latest
    steps:
      - name: æ£€å‡ºä»£ç 
        uses: actions/checkout@v4

      - name: é‡å¤ä»£ç æ£€æµ‹ (jscpd)
        run: |
          npx jscpd . --ignore "node_modules,build,dist,coverage" --output /tmp/jscpd-report
        continue-on-error: true

      - name: ä¸Šä¼ é‡å¤ä»£ç æŠ¥å‘Š
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: jscpd-report
          path: /tmp/jscpd-report
